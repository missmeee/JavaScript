# 

# 1. helloword

控制浏览器弹出警告
`alert("hello!!!")`
```javascript
    alert("hello!!!")
```
在浏览器页面中输出内容
```javascript
    document.write("我写在哪里？？")
 ```
在控制台输出内容
```javascript
    console.log("我在哪里出来？")
```

# 2. JS代码编写的位置
 1. 可以将js代码编写到外部js文件中，然后引入。写到外部文件中可以在不同的页面中同时引用，也可以利用到浏览器的缓存机制
    
    **推荐使用**
    
```html
<script type="text/javascript" src="./js/01script.js"></script>
```

**一旦script标签用于引入外部文件后就不能再在标签中编写js代码,如需要，可再创建script标签**

2. 可以将js代码编写到onclick属性中,当我们点击按钮时，js代码才会执行。
     
```html
     <button onclick="alert('别点我！！')">点我一下</button>
```
 
3. 可以将js代码写在超链接的href属性中,这样点击超链接时也会执行js代码  

```html
     <a href="javascript:alert('hello')">也点我一下</a>
     <a href="javascript:;">也点我一下</a>
```
**虽然可以直接写在属性中 但是结构与行为耦合 不利于维护 不推荐使用**

4. 可以将js代码写在script标签

```html
  <script type="text/javascript">
      alert('这是内部script标签')
  </script>
```


# 3. 基本语法
1. js中严格区分大小写。
2. js中每一条语句以分号结尾。(如果不写分号，浏览器会自动添加，影响性能，且浏览器可能加错分号)
3. js中会自动忽略多个空格和换行。

```javascript
/*
    多行注释
*/
//单行注释
```
# 4. 字面量和变量
    
**字面量**，即常量 都是一些不可改变的量

> 比如：1，2，3，4
> 可以直接使用，但一般不会使用
	
**变量**  变量可以用来保存字面量，而且变量的值是可以任意改变的
    
**声明变量**
在就是中使用var关键字来声明变量


```javascript
//为变量a赋值
var a = 123;
console.log(a);
document.write(a);
```
# 5. 标识符
- 在JS中所有的可以由我们自主命名的都可以称为是标识符
- 例如：变量名、函数名、属性名等等
- 命名一个标识符时需遵守以下规则

 1. 标识符中可以含有字母、数字、下划线、$
 2. 标识符不能以数字开头
 3. 标识符不能是ES中的关键字或保留字
 4. 标识符一般采用驼峰命名法
        - 首字母小写，每个单词的开头字母大写，其余小写
        - helloWorld   xxxYyyZzz

**JS底层保存标识符时实际上是采用的Unicode编码**
 ```javascript
 var a = 12;
 
 document.write(if);
 ```
 
 # 6. 数据类型

数据类型指的是字面量的类型

在JS中一共有六种数据类型
- **String 字符串**
-  **Number 数值**
-  **Boolean 布尔值**
-  **Null 空值**
-  **Undefined 未定义**
-  *Object 对象*
         
**其中前五种为基本数据类型，Object为引用数据类型**


## 6.1 String字符串
- 在JS中字符串需要使用引号引起来
- 使用双引号和单引号都可以，但是不要混着用
 */
 ```javascript
 var str = "hello";
 
 str = '他说："我是xxx"';
 ```
 
     在字符串中我们可以使用\作为转义字符，
     当表示一些特殊符号时可以使用转义字符
 
     \\" 表示 "
	 
     \\' 表示 '
	 
     \n 表示换行
	 
     \t 制表符
	 
     \\\ 表示 \
```javascript
 document.write(str);
 console.log(str);
 //alert("你好\n我是")
 ```

     在JS中所有的数值都是Number类型，
     包括整数和浮点数（小数）
 
     JS中可以表示的数字的最大值
`Number.MAX_VALUE`=

`1.7976931348623157e+308`
    
`Number.MIN_VALUE` 最小的正值
     
如果使用number表示的数字超过了最大值，则会返回`Infinity`，无穷大
         `Infinity`也是`number`类型
     
`NaN`也是一个特殊的数字，表示Not a Number（不是一个数字）
``` javascript
 var c = 1.234;  //数字
 var d = "1.234" //字符串
 document.write(c);
 /*
     可以使用一个运算符 typeof 来检查一个变量的类型
         语法 typeof 变量
          字符串返回 string
          数值返回 number
 */
 console.log(typeof d);
 ```
    
**如果使用JS进行浮点数运算，可能得到一个不精确的结果**

**所以千万不要使用JS进行对精确度要求较高的运算**
 
 

## 6.2布尔值
布尔值只有两个，用于逻辑判断
- true - 真
- false - 假
 
     
## 6.3 Null
`Null`类型的值只有一个，就是`null`

`null`这个值专门用来表示一个为空的对象

使用`typeof`检查一个`null`值时，会返回`object`
 
## 6.4 Undefined
`Undefined`类型的值只有一个，就是`ndefined`

当声明一个变量，不赋值时，它的值就是`undefined`

使用`typeof`检查一个`undefined`值时，会返回`undefined`
 */

# 7. 强制类型转换
指将一个数据类型强制转换为其他的数据类型

## 7.1 将其他数据类型转换为string
>方法一：
>    - 调用被转换数据类型的`toString()`方法
>    - 该方法不会影响原变量，会将转换结果返回
>    - 注意：`null`和`undefined`没有`toString`，调用会报错
	
>方法二：
>    - 调用`String()`函数，并将被转换的数据作为参数传递给函数
>    - 使用`String()`函数做强制转换时，
>        对于`Number`和`Boolean`实际上就是调用的`toString()`方法
>        但是对于`null`和`undefined`，就不会调用`toString()`方法
>            它会将`null`、`undefined`直接转换为"null"、"undefined"

```javascript
var a = 1223;
//调用a的toString()方法
var b = a.toString();
document.write(typeof b)
var c = 777888;
c = String(c);
document.write(typeof c);
```

## 7.2 其他的数据类型转换为Number
>方法一：
> 使用Number()函数
>    - 字符串 --> 数字
>        1. 如果是纯数字的字符串，则直接将其转换为数字
>        2. 如果字符串中有非数字的内容，则转换为NaN
>        3. 如果字符串为空串或全是空格，则转换为0
>    - 布尔值 --> 数字
>        true  --> 1
>        false --> 0
>    
>    - null --> 数字 0
>    - undefined --> 数字 NaN
                
>方法二：
>这种方法专门用来对付字符串
>	- parseInt() 把一个字符串转换为一个整数
>	- parseFloat() 把一个字符串转换为一个浮点数

```javascript
var f = " ";
f = Number(f);
document.write(typeof f)
document.write('\nf='+f)
/* 
    调用parseInt()函数将a转换为Number
    parseInt()可以将一个字符串中的有效的整数内容取出来
    然后转换为Number
*/
var p = "123px";
p = parseInt(p);


// parseFloat()作用和parseInt()类似，不同的是它可以获得有效的小数
p = "123.456px"
/* 
    如果对非String使用parseInt()或parseFloat()
    它会先将其转换为String然后在操作
*/
p = null
document.write('\np='+p);
```
## 7.3 转换为Boolean

使用`Boolean()`函数
- 数字 --> Boolean
    除了0和NaN，其余的都是true
- 字符串 --> Boolean
    除了空串，其余都是false

- null和undefined都会转换为false
```javascript
a = 123;
a = Boolean(a);
document.write('\na='+a);
```

# 8. 其他进制的数字

在JS中，如果需要表示16进制的数字，则需要以0x开头
        
8进制数字，以0开头

2进制数字，以0b开头，不是所有浏览器都支持

```javascript
    //16进制
    a = 0x10;
    a = 0xff;
    a = 0xCafe;
    //8进制
    a = 010;
    //2进制
    a = 0b10;

    //像"070"这种字符串，有些浏览器会当作8进制，有些会当作10进制
    a = 070;
    //可以在parseInt()中传递第二个的参数，来指定数字的进制
    a = parseInt(a,10);
    document.write('a:'+a);
```
# 9. 运算符
运算符也叫操作符

通过运算符可以对一个或多个值进行运算，并获取运算结果

>比如：`typeof`就是运算符

## 9.1 算术运算符
    
- \+  可以对两个值进行相加，返回结果
	- 如果对两个字符串进行加法运算，则会将其拼接为一个字符串
	- 任何值和字符串做加法运算，都会先转换为字符串再和字符串拼接（可以利用这一特点将任意数据类型转换为字符串）
- -
- *
- /
- % 取模运算，取余数
	- 当对非`Number`类型进行运算时会先转换为`Number`
	- 任何值和`NaN`做运算都会转换为`NaN`

**任何值做- * / 运算时都会转换为Number**
- 我们可以利用这一特点做隐式的类型转换
- 可以通过为一个值-0 *1 /1来将其转换为`Number`
## 9.2 一元运算符
### 9.2.1 正负号
一元运算符，只需要一个操作数
\+ 正号
- 正号不会对数字产生任何影响
\- 负号
- 负号可以对数字进行负号的取反

对于非Number类型的值：
- 它会将其转换为`Number`，然后再运算
- 可以对一个其他的数据类型使用+，来将其转换为`Number`
- 它的原理和`Number()`函数一样

### 9.2.2 自增 ++
- 通过自增可以使变量在自身的基础上增加1
- 对于一个变量自增以后，原变量的值会立即自增1
- 自增分成两种，后++（a++）和前++（++a）
- 无论是`a++`还是`++a`，都会立即使原变量的值自增1
- **不同的是`a++`和`++a`本身的值不同**
	+ a++的值等于原变量的值（自增前的a值）
	+ ++a的值等于原变量的新值（自增后的a值）

```javascript
var a = 1;
console.log(a++);  //输出1，此时a等于2
console.log(++a);  //输出3，此时a等于3

var d = 20；
var result =d++ + ++d + d;   //20+22+22
 console.log(result);   // 64
 
var h = 10;
 h = h++;  //h = 20
```
### 9.2.3 自减
- 通过自减可以使变量在自身的基础上减1
- 自减分成两种：后--（a--）和前--（--a）
- 无论是`a--`还是`--a`都会立即使原变量的值自减1
- 不同的是`a--`和`--a`的值不同
	- `a--`是变量的原值（自减前的值）
	- `--a`是变量的新值（自减后的值）

## 9.3 逻辑运算符
### 9.3.1 ！非
- ！可以用来对一个值进行非运算
- 指对一个布尔值进行取反操作
	- true变false，false变true
- 如果对于一个布尔值两次取反，则不会发生变化
- 如果对非布尔值进行运算，则会将其转换为布尔值，然后再取反
	- 所以我们可以利用该特点，将其他数据类型转换为布尔值，可以为任意数据类型取两次反，将其转换为布尔值（原理与Boolean函数一样）

### 9.3.2 && 与
- &&可以对符号两侧的值进行与运算并返回结果
- 运算规则：
	* 两个值中只要有一个值为false就返回false
	* **只有两个值都为true才返回true**
- JS中的“与”属于短路的与，如果第一个值为false，则不会看第二个值

```javascript
//两个都是true才返回true
result = true&&true;
//只要有一个false则返回false
result = true&&false;
result = false&&true;
result = false&&false;

//第一个值是true，会检查第二个值
true && alert("看我出不出来");

//第一个值为false，不会检查第二个值
false && alert("看完出不出来");
```

### 9.3.3 || 或
- ||可以对符号两侧的值进行或运算并返回结果
- 运算规则：
	- 两个值中只要有一个true，就返回true
	- **如果两个值都为false，才返回false**
	- JS中的“或”属于短路的或，如果第一个值为true则不会检查第二个值

### 9.3.4 非布尔值的情况
- 对于非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算，并且返回原值
- **与运算**
	- 如果第一个值为true，则必然返回第二个值
	- 如果第一个值为false，则直接返回第一个值
- **或运算**
	- 如果第一个值为true，则直接返回第一个值
	- 如果第一个值为false，则必然返回第二个值

```javascript
//true&&true
//与运算，如果两个值都为true，则返回后面的
var result = 5 && 6;

//与运算，如果两个值中有false，则返回靠前的false
//false && true
result = 0 && 2;
result = 2 && 0;
//false = NaN && 0;
result = NaN && 0;
result = 0 && NaN;

//或运算
//true || true
//如果第一个值为true，则直接返回第一个值
result = 2 || 1;
result = 2 || NaN;

//如果第一个值为false，则必然返回第二个值
result = NaN || 2;
result = NaN || 0;
```

## 9.4 赋值运算符

- a += 5等于a = a + 5
- a -= 5等于a = a - 5
- a *= 5等于a = a * 5
- a /= 5等于a = a / 5
- a %= 5等于a = a % 5

## 9.5 关系运算符
通过关系运算符可以比较两个值之间的大小关系

如果关系成立它会返回`true`，不成立返回`false`

- \> 大于号
	- 判断符号左侧的值是否大于右侧的值

**任何值和`NaN`做比较都会返回`false`**
**如果符号的两侧都是字符串，不会将其转换为数字进行比较，会转换为Union编码比较**

```javascript
//比较两个字符串时，比较的是字符串的字符编码
console.log("a"<"b");  //true
//比较字符编码时是一位一位进行比较
//如果两位一样，则比较下一位，所以借用它来对英文进行排序
console.log("abc"<"b");//true
console.log("bbc"<"b");//false


```
**注意：在比较两个字符串型的数字时，一定一定要转型（加+号）**

## 9.6 编码
在字符串中使用转义字符输入`Unicode`编码

`\u`四位编码

```javascript
console.log("\u2620")
```

在网页中使用`Unicode`编码

`&#`编码；这里需要十进制

```html
<h1>&#9760;</h1>
```

## 9.7 相等运算符
相等运算符用来比较两个值是否相等，如果相等会返回true，否则返回false

1. 使用 `==` 来做相等运算

当使用 `==` 来比较两个值时，如果值的类型不同，则会自动进行类型转换，将其转换为相同的类型，然后再比较。

>**`NaN`不与任何值相等，包括它自己**
>
>**可以使用`isNaN()`函数来判断某个值是否为`NaN`**

2. 使用`!=`来做不等运算
3. 使用`===`来做全等运算
	- 用来判断两个值是否全等，和相等类似，不同的是它不会进行类型的转换
	- 如果两个值的类型不同，直接返回false

4. 使用`!==`来做不全等运算
	- 不会自动进行类型转换

## 9.8 条件运算符
条件运算符又叫三元运算符

>语法：
>     条件表达式?语句1:语句2;

执行的流程：
	- 条件运算符在执行时，首先对条件表达式进行求值，
	- 如果该值为true，则执行语句1，并返回执行结果
	- 如果该值为false，则执行语句2，并返回执行结果

```javascript
var a = 10;
var b = 20;

a > b ? alert("a大"):alert("b大");

```

**如果条件表达式为非布尔值，会先转换为布尔值**

# 10. 流程控制语句

通过流程控制语句可以控制程序执行的流程，使程序可以根据一定的条件来选择执行

语句的分类：
1. 条件判断语句
2. 条件分支语句
3. 循环语句

## 10.1 条件判断语句
使用条件判断语句可以在执行某个语句之前进行判断，如果条件成立才会执行语句，条件不成立则语句不执行

```javascript
//if语句
//    语法一：
        if('条件表达式'){
			语句...
		}   
```
if语句在执行时，会先对条件表达式进行求值判断
- 如果条件表达式的值为true，则执行if后的语句
- 如果条件表达式的值为false，则不会执行if后的语句

```javascript
//if语句
//    语法二：
	if("条件表达式"){
		语句...
	}else{
		语句...
	}

```
if...else...语句

当该语句执行时，会先判断表达式，若为true，则执行if后的语句；若为false则执行else后的语句。
```javascript
var age = 40;
if (age>=60) {
	alert('你已经退休了...')
} else{
	alert('你还没退休！！')
}

```

```javascript
//if语句
//    语法三：
	if("条件表达式"){
		语句...
	}else if{
		语句...
	}else if{
		语句...
	}else{
		语句...
	}

```

## 10.2 条件分支语句
switch语句

```javascript
var score = 20;

switch (score>=60){
	case true:
		console.log('合格')
		break;
	default:
		console.log('不合格')
		break;
}
```
## 10.3 循环语句
### 10.3.1 while循环
while语句在执行时，先对表达式进行求值判断，如果为true则执行循环体，循环体执行完毕后继续对表达式进行判断，如果为true则继续进行，以此类推；如果值为false终止循环。

可以用break来终止循环

```javascript
// 1.初始化一个变量
var i = 1;
// 2.在循环中设置一个表达式
while (i<10){
	alert(i);
	// 3.定义一个更新表达式，每次更新初始化变量
	i++;
}
```

do...while语句在执行时，会先执行循环体，循环体执行完毕后，再对while后的条件表达式进行判断，如果结果为true，则继续执行循环体，执行完毕继续判断，若为false则终止。
 
 
> **do...while先执行后判断，至少执行一次语句**
### 10.3.2 for循环

for语句，也称为for循环，和while类似，但更常用。

在for循环中，为我们提供了专门的位置来放三个表达式：
1. 初始化表达式
2. 条件表达式
3. 更新表达式

```javascript
	for (i = 0; i < 10; i++) {  //初始化表达式；条件表达式；更新表达式
				alert(i);
	}
```

for循环执行流程：
1. 执行初始化表达式，初始化变量
2. 执行条件表达式，判断是否执行循环
3. 如果为true，执行循环语句；为false，终止循环
4. 执行更新表达式，更新表达式执行完毕继续重复

### 10.3.3 break 和 continue

**break**

break关键字可以用来退出switch或循环语句

**不能在if语句中使用break和continue**

break关键字会立即终止离他最近的循环语句
>可以为循环语句创建一个label，来标识当前的循环
>
>label:循环语句
>
>使用break语句时，可以在break后跟着一个label，这样break将会结束指定的循环，而不是最近的

```javascript
outer:
for(var i=0; i<5; i++){
	console.log('i='+i);
	for(var j=0; j<5; j++){
		console.log('j='+j);
		break outer
	}
}


```

**continue**

continue关键字可以用来跳过当次循环

同样continue也是默认只会对最近的循环起作用

# 11. 对象

基本数据类型都是单一的值，如“hello”、123、true，值和值之间没有任何的联系。
 
 对象属于一种复合的**数据类型**，在对象中可以保存多个不同数据类型的属性。

对象的分类：
1. 内建对象 - 由ES标准中定义的对象，在任何的ES的实现中都可以使用，比如：Math、String、Number。
2. 宿主对象 - 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象，比如BOM、DOM。
3. 自定义对象 - 由开发人员自己创建的对象。

**读取对象中没有的属性不会报错，而是会返回undefined**

- 对象的属性名不强制要求遵守标识符的规范，但是使用时尽量按照规范去使用
- 如果要使用特殊的属性名，不能采用.的方式来操作。 对象["属性名"] = 属性值  读取时也需要采用这种方式。
- 使用[]这种形式去操作属性，更加灵活，在[]中可以直接传递一个变量，变量是多少就读取哪个属性

**属性值：**
- JS对象的属性值，可以是任意的数据类型，包括对象

in运算符
- 通过该运算符可以检查一个对象中是否含有指定的属性，如果有返回true
- 语法： "属性名" in 对象

 **基本和引用数据类型**

JS中的变量都是保存到栈内存中的

基本数据类型的值直接在栈内存中存储，值与值之间是独立存在，修改一个变量不会影响其他变量

对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟一个新的空间。而变量保存的是对象的内存地址，如果两个变量保存的是同一个对象引用，当通过一个变量修改属性时，另一个也会受到影响。

>当比较两个基本数据类型的值时，就是比较值
>
>而比较两个引用数据类型时，比较的是对象的内存地址，内存地址不同就会返回false

# 12. 函数

- 函数也是对象
- 函数中可以封装一些功能（代码），在需要时可以执行这些功能
- 使用`typeof`检查一个函数对象时会返回`function`

## 12.1 函数的参数
- 函数的实参可以是任意的数据类型
- 调用函数时解析器不会检查实参的类型，所以，可能会收到非法的参数，需要对参数进行类型检查
- 调用函数时解析器也不会检查实参的数量，多余的实参不会被赋值；实参数量少于形参数量，则会为undefined

## 12.2 函数的返回值

- 可以使用`return`来设置函数的返回值
- 语法：  return 值
- `return`后的值将会作为函数的执行结果返回，可以定义一个变量来接受结果
- 在函数中`return`后的语句都不会执行

## 12.3 函数的实参

- 实参可以是任意的数据类型，也可以是一个对象
- 当我们参数过多时，可以将参数封装到一个对象中，然后通过对象传递

```javascript
	function sayHello(o){
		console.log('我是'+o.name+',今年我'+o.age+'岁了,我是一个'+o.gender+'人,我住在'+o.adress);
		
	}
	
	var obj={
		name = '孙悟空',
		age = 18,
		address = '花果山',
		gender = '男'
	}
	
	sayHello(obj);
```

## 12.4 函数的返回值

- 函数的返回值可以是任意数字类型，包括**对象**，**函数**。

```javascript
	
	function fun(){
		var obj = {name:'沙和尚'};
		
		return obj;
	}
	
	
	function fun2(){
		function fun2(){
			alert('我是fun3');
		}
		return fun2;
	}

```

## 12.5 方法

- 函数也可以称为对象的属性，如果一个函数作为一个对象的属性保存，那么我们称这个函数是这个对象的方法
- 调用这个函数就说调用对象的方法（method）
- *只是名称的区别，本质没有区别*

## 12.6 作用域

- 作用域指一个变量的作用范围
- 在JS中一共有两种作用域：
	1. [全局作用域](#全局作用域)
	2. [函数作用域](#函数作用域)

### 全局作用域
- 直接编写在script标签中的JS代码，都在全局作用域
- 全局作用域在页面打开时创建，在页面关闭时销毁
- 在全局作用域中有一个全局对象window，我们可以直接使用
	- window代表的是浏览器窗口，由浏览器创建
- **在全局作用域中，创建的变量都会作为window对象的属性保存**
- 在全局作用域中，创建的函数都会作为window对象的方法保存
- 全局作用域中的变量都是全局变量，在页面任意的部分都可以访问的到

>变量的声明提前
>
>- 使用var关键字声明的变量，会在所有的代码执行之前被声明
>- 但是如果声明变量时不使用var关键字，则变量不会被声明提前

>函数的声明提前
>
>- 使用函数声明形式创建的function函数(){}，它会在所有的代码执行之前就被创建，所以我们可以在函数声明前来调用函数
>- 使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用

### 函数作用域

- 调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁
- 每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的
- 在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量
- 当在函数作用域中操作一个变量时，会先在自身作用域中寻找，如果有则直接使用，若没有则在上一级作用域中寻找，直到找到全局作用域，若依然没有则会报错
- 在函数中要访问全局变量可以使用`window`对象
- 在函数作用域中也有声明提前的特性，使用var声明的变量，会在函数中所有的代码执行前被声明，函数声明也会在函数中所有的代码执行之前执行
- 在函数中，不使用var声明的变量都会成为全局变量
- 定义形参就相当于在函数作用域中声明了变量

## 12.7 this

- 解析器在调用函数每次都会向函数内部传递一个隐含的参数，这个隐含的参数就是`this`，`this`指向的是一个对象，这个对象我们称为函数执行的上下文对象
- 根据函数的调用方式不同，`this`会指向不同的对象。
	1. 以函数形式调用时，`this`永远都是`window`
	2. 以方法形式调用时，`this`就是调用方法的那个对象
	3. 当以构造函数的形式调用时，`this`就是新创建的那个对象

## 12.8 构造函数

构造函数就是一个普通函数，创建方式与普通函数没有区别。

不同的是构造函数习惯上首字母大写

- 区别：普通函数直接调用，构造函数需要使用new关键字来调用


- 构造函数的执行流程：
1. 立刻创建一个新的对象
2. 将新建的对象设置为函数中的`this`，在构造函数中可以使用`this`来引用新建的对象
3. 逐行执行函数中的代码
4. 将新建的对象作为返回值返回

使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个**类**

我们将通过一个构造函数创建的对象，称为是该类的实例。

>使用`instanceof`可以检查一个对象是否是一个类的实例
>
>语法： 对象 instanceof 构造函数

**所有的对象都是Object的后代**


# 13. 原型 Prototype

我们所创建的每一个函数，解析器都会向函数中添加一个属性`prototype`，这个属性对应着一个对象，这个对象就是我们所谓的原型对象

如果函数作为普通函数调用`prototype`没有任何作用

- 当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过__proto__来访问该属性。
- 原型对象就相当于一个公共区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中
- 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用
- 以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了

>可以使用对象的`hasOwnProperty()`来检查对象自身中是否含有该属性，只有当对象自身中含有属性时，才会返回true

原型对象也是对象，所以它也有原型，当我们使用一个对象的属性或方法时，会先在自身中寻找，自身中如果有，则直接使用。如果没有则去原型对象中寻找，如果原型对象中有则使用；如果没有则去原型的原型中寻找，直到找到Object对象的原型。

`Object`对象的原型没有原型，如果在`Object`原型中依然没有找到，则返回`undefined`

# 14.垃圾回收（GC）

- 程序运行过程中会产生垃圾，垃圾积攒过多会导致程序运行速度过慢，所以我们需要一个垃圾回收机制，来处理程序运行过程中产生垃圾
- 当一个对象没有任何的变量或属性对他进行引用，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行清理
- 在JS中会有自动垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收。
- **我们需要做的只是要将不再使用的对象设置为null即可。**

# 15.数组（Array）
[数组](https://github.com/missmeee/StudyCode/blob/master/JavaScript/19数组.html)

- 数组也是一个对象，它和普通的对象功能类似，也是用来储存一些值的
- 不同的是普通对象是使用字符串作为属性名的，而数组是使用数字来作为索引操作元素
- 数组的存储性能比普通对象要好，在开发中我们经常使用数组来存储一些数据


**数组中的元素可以是任意数据类型，也可以是对象**

## 15.1 数组的方法

1. push( )
	- 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新长度
	- 可以将要添加的元素作为方法的参数传递，这样这些元素将会自动添加到数组的末尾
	- 该方法会将数组的新的长度作为返回值返回
2. pop( )
	- 该方法可以删除数组的最后一个元素，并将被删除的元素作为返回值返回。
3. unshift( )
	- 向数组开头添加一个或多个元素，并返回新的数组长度
4. shift( )
	- 可以删除数组的第一个元素，并将被删除的元素作为返回值返回

```javascript
var arr = ['孙悟空','猪八戒'];

arr.push('沙和尚','牛魔王','唐三藏');  // arr = ['孙悟空','猪八戒','沙和尚','牛魔王','唐三藏']  返回 5

arr.pop();    // arr = ['孙悟空','猪八戒','沙和尚','牛魔王']   返回 ‘唐三藏’

arr.unshift('玉皇大帝'); // arr = ['玉皇大帝','孙悟空','猪八戒','沙和尚','牛魔王']  返回 5
arr.shift(); //arr = ['孙悟空','猪八戒','沙和尚','牛魔王']  返回 '玉皇大帝'
```

## 15.2 数组的遍历

所谓的遍历数组就是将数组中的所有元素都取出来


```javascript
var arr =  ['孙悟空','猪八戒','沙和尚','牛魔王','唐三藏'];

for(var i = 0; i<arr.length; i++){
	console.log(arr[i]);
}
```

JS中还为我们提供了一个方法，用来遍历数组

**forEach()**
>**IE8及以下浏览器不兼容**

`forEach()`方法需要一个函数作为参数。 

- 像这种函数，来由我们创建但是不由我们调用的，我们称为回调函数
- 数组中有几个元素函数就会执行几次,每次执行时，浏览器会将遍历到的元素以实参的形式传递进来，我们可以来定义形参，来读取这些内容
- 浏览器会在回调函数中传递三个参数：
	- 第一个参数：当前元素
	- 第二个参数：元素对应的索引
	- 第三个参数：整个数组

```javascript
arr.forEach(function(value,index,obj){
	console.log(value);
})

```

## 15.3 数组的方法

[数组的方法](https://github.com/missmeee/StudyCode/blob/master/JavaScript/21数组的方法.html)


# 16. 函数的方法

## call()和apply()
- 这两个方法都是函数对象的方法，需要通过函数对象来调用
- 当对函数调用call()和apply()都会调用函数执行
- 在调用call()和apply()可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的this

- call()方法可以将实参在对象之后依次传递
- apply()方法需要将实参封装到一个数组中统一传递

>this的情况
>1. 以函数形式调用时，this永远都是window
>2. 以方法的形式调用时，this是调用方法的对象
>3. 以构造函数的形式调用时，this是新创建的那个对象
>4. 使用call和apply调用时，this是指定的那个对象

## arguments

- 在调用函数时，浏览器每次都会传递进两个隐含的参数
	1. 函数上下文对象this
	2. 封装实参的对象arguments，arguments是一个类数组对象，也可以通过索引来操作数据 
		- arguments.length可以获取实参的长度
		- 我们即使不定义形参，也可以通过arguments来使用实参
		- arguments[0] 表示第一个实参
		- arguments[1] 表示第二个实参
		- arguments有一个属性为callee，这个属性对应一个函数对象，就是当前正在执行的函数对象


# 17.Date

- 在JS中使用Date对象来表示一个时间

```javascript
var d = new Date();

console.log(d);

//创建指定时间
//格式 月份/日/年 时:分:秒
var d2 = new Date('2/3/2022 12:30:00');

```

- getDate() 获取当前日期对象是几日
- getDay() 获取当前日期对象是周几（会返回0-6的值，0为周日）
- getMonth() 获取当前日期对象的月份（返回0-11，0为1月，11为12月）
- getFullYear() 获取当前日期的年份

- getTime() 获取当前日期对象的时间戳
	- 从1970年1月1日到当前时间的毫秒数
- Date.now() 获取当前的时间戳

# 18.正则表达式

- 正则表达式用于定义一些字符串的规则，计算机可以根据正则表达式检查一个字符串是否符合规则，获取将字符串中符合规则的内容提取出来
- 语法： var 变量 = new RegExp("正则表达式","匹配模式");
- 正则表达式的方法 `test()`
	- 使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，如果符合返回true，否则返回false

>- 可以传递一个匹配模式作为第二个参数：
>1. i 忽略大小写
>2. g 全局匹配模式

- 使用字面量创建正则表达式
- 语法： var 变量 = /正则表达式/匹配模式

## 量词

- 通过量词可以设置一个内容出现的次数
- 量词只对它前面的一个内容起作用，可以使用括号
- {n} 正好出现n次
- {m,n} 出现m-n次
- {m,}  m次以上
- \+ 至少一次，相当于{1,}
- \* 0个或多个，相当于{0,}
- ? 0个或一个，相当于{0,1}
- ^ 表示开头，/^a/
- $ 表示结尾，/a$/

## 转义字符

在正则表达式中使用`\`作为转义字符

- . 表示任意字符
- \. 表示.
- \\ 表示\

**注意：在构造函数中，由于它的参数是一个字符串，而`\`是字符串的转义字符，所以如果要使用`\`则需要使用`\\`来代替**

# 19.事件

用户与浏览器之间的交互行为，比如：点击按钮、鼠标移动、关闭窗口。。。


# 20.BOM

- 浏览器对象模型
- BOM可以使我们通过JS来操作浏览器
- 在BOM中为我们提供了一组对象，用来完成对浏览器的操作
- BOM对象
	- window：代表的是整个浏览器的窗口，同时window也是网页中的全局对象
	- Navigator：代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器
	- Location：代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面
	- History：代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录，但不能获取到浏览器具体的历史记录，只能操作浏览器向前或向后翻页。
	- Screen：代表用户的屏幕信息，通过该对象可以获取到用户屏幕的信息。

这些BOM对象在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接来使用